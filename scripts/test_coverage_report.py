#!/usr/bin/env python3
"""
Test Coverage Report Script for Cerby Identity Automation Platform

This script generates a comprehensive test coverage report for all Phase 1 components,
ensuring that each subtask has >95% test coverage as required for progression.
"""

import subprocess
import sys
import json
import os
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Tuple, Optional
import argparse
import xml.etree.ElementTree as ET

# Add project root to Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))


class TestCoverageReporter:
    """Generates comprehensive test coverage reports for the project."""

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.coverage_threshold = 95.0  # Required 95% coverage
        self.test_results = {}
        self.coverage_data = {}

    def run_tests_with_coverage(self, test_path: str = "tests/unit") -> bool:
        """
        Run pytest with coverage for specified test path.

        Args:
            test_path: Path to test directory or file

        Returns:
            bool: True if tests passed, False otherwise
        """
        cmd = [
            "pytest",
            test_path,
            f"--cov={self.project_root}/src",
            "--cov-report=json",
            "--cov-report=xml",
            "--cov-report=term-missing",
            "--cov-report=html",
            "--json-report",
            f"--json-report-file={self.project_root}/test_report.json",
            "-v"
        ]

        print(f"Running tests with coverage: {' '.join(cmd)}")
        result = subprocess.run(
            cmd,
            cwd=self.project_root,
            capture_output=True,
            text=True
        )

        print(result.stdout)
        if result.stderr:
            print("STDERR:", result.stderr)

        return result.returncode == 0

    def parse_coverage_json(self) -> Dict:
        """Parse the coverage.json file generated by pytest-cov."""
        coverage_file = self.project_root / "coverage.json"
        if not coverage_file.exists():
            print("Warning: coverage.json not found")
            return {}

        with open(coverage_file, 'r') as f:
            data = json.load(f)

        return data

    def parse_test_report_json(self) -> Dict:
        """Parse the test report JSON file."""
        report_file = self.project_root / "test_report.json"
        if not report_file.exists():
            print("Warning: test_report.json not found")
            return {}

        with open(report_file, 'r') as f:
            data = json.load(f)

        return data

    def analyze_coverage_by_task(self) -> Dict[str, Dict]:
        """Analyze coverage organized by Phase 1 tasks."""
        coverage_data = self.parse_coverage_json()
        test_data = self.parse_test_report_json()

        task_mapping = {
            "Task 1.1": ["src/core/config.py", "main.py"],
            "Task 1.2": ["main.py", "src/api/"],
            "Task 1.3": ["main.py", "src/core/config.py"],
            "Task 1.4": ["conftest.py"],
            "Task 1.5": ["src/core/config.py"],
            "Task 2.1": ["src/db/database.py"],
            "Task 2.2": ["src/db/models/user.py", "src/db/models/identity.py"],
            "Task 2.3": ["src/db/models/saas_app.py"],
            "Task 2.4": ["src/db/models/policy.py"],
            "Task 2.5": ["src/db/models/audit.py"],
            "Task 3.1": ["src/ingestion/synthetic.py"],
            "Task 3.2": ["src/ingestion/scim.py"],
            "Task 3.3": ["src/ingestion/webhook.py"],
            "Task 3.4": ["src/ingestion/batch.py"],
            "Task 3.5": ["src/ingestion/transformers/"],
            "Task 3.6": ["src/ingestion/streaming.py"],
        }

        task_coverage = {}

        for task, file_patterns in task_mapping.items():
            task_stats = {
                "files": [],
                "total_lines": 0,
                "covered_lines": 0,
                "missing_lines": 0,
                "coverage_percent": 0.0,
                "test_count": 0,
                "test_passed": 0,
                "test_failed": 0,
                "meets_threshold": False
            }

            if "files" in coverage_data:
                for pattern in file_patterns:
                    for file_path, file_data in coverage_data["files"].items():
                        if pattern in file_path:
                            summary = file_data.get("summary", {})
                            task_stats["files"].append({
                                "path": file_path,
                                "coverage": summary.get("percent_covered", 0)
                            })
                            task_stats["total_lines"] += summary.get("num_statements", 0)
                            task_stats["covered_lines"] += summary.get("covered_lines", 0)
                            task_stats["missing_lines"] += summary.get("missing_lines", 0)

            # Calculate coverage percentage
            if task_stats["total_lines"] > 0:
                task_stats["coverage_percent"] = (
                    task_stats["covered_lines"] / task_stats["total_lines"] * 100
                )
                task_stats["meets_threshold"] = task_stats["coverage_percent"] >= self.coverage_threshold

            # Add test statistics
            if "tests" in test_data:
                task_test_pattern = task.replace("Task ", "test_").replace(".", "_")
                for test in test_data["tests"]:
                    if task_test_pattern in test.get("nodeid", ""):
                        task_stats["test_count"] += 1
                        if test.get("outcome") == "passed":
                            task_stats["test_passed"] += 1
                        else:
                            task_stats["test_failed"] += 1

            task_coverage[task] = task_stats

        return task_coverage

    def generate_html_report(self, task_coverage: Dict[str, Dict]) -> str:
        """Generate an HTML coverage report."""
        html = []
        html.append("""
<!DOCTYPE html>
<html>
<head>
    <title>Cerby Phase 1 Test Coverage Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background-color: white; padding: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        h2 { color: #555; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .summary { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .task { margin-bottom: 30px; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
        .task-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .coverage-bar { width: 100%; height: 20px; background-color: #e0e0e0; border-radius: 10px; overflow: hidden; }
        .coverage-fill { height: 100%; transition: width 0.3s ease; }
        .pass { background-color: #4caf50; }
        .fail { background-color: #f44336; }
        .warning { background-color: #ff9800; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 10px; }
        .stat { background-color: #f5f5f5; padding: 10px; border-radius: 5px; text-align: center; }
        .stat-label { font-size: 12px; color: #666; }
        .stat-value { font-size: 20px; font-weight: bold; color: #333; }
        .file-list { margin-top: 10px; font-size: 14px; }
        .file-item { padding: 5px; background-color: #f9f9f9; margin-bottom: 5px; border-radius: 3px; }
        .threshold-met { color: #4caf50; font-weight: bold; }
        .threshold-not-met { color: #f44336; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cerby Identity Automation Platform</h1>
        <h2>Phase 1 Test Coverage Report</h2>
        <div class="summary">
            <p><strong>Generated:</strong> {datetime}</p>
            <p><strong>Coverage Threshold:</strong> {threshold}%</p>
            <p><strong>Overall Status:</strong> <span class="{overall_class}">{overall_status}</span></p>
        </div>
        """)

        # Calculate overall statistics
        total_lines = sum(t["total_lines"] for t in task_coverage.values())
        covered_lines = sum(t["covered_lines"] for t in task_coverage.values())
        overall_coverage = (covered_lines / total_lines * 100) if total_lines > 0 else 0
        all_tasks_pass = all(t["meets_threshold"] for t in task_coverage.values())

        html[0] = html[0].format(
            datetime=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            threshold=self.coverage_threshold,
            overall_class="threshold-met" if all_tasks_pass else "threshold-not-met",
            overall_status="✅ ALL TASKS MEET THRESHOLD" if all_tasks_pass else "❌ SOME TASKS BELOW THRESHOLD"
        )

        # Add task details
        for task, stats in sorted(task_coverage.items()):
            coverage_class = "pass" if stats["meets_threshold"] else "fail"
            if stats["coverage_percent"] > 90 and not stats["meets_threshold"]:
                coverage_class = "warning"

            html.append(f"""
        <div class="task">
            <div class="task-header">
                <h3>{task}</h3>
                <span class="{coverage_class}">{stats['coverage_percent']:.1f}%</span>
            </div>
            <div class="coverage-bar">
                <div class="coverage-fill {coverage_class}" style="width: {stats['coverage_percent']}%"></div>
            </div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">Total Lines</div>
                    <div class="stat-value">{stats['total_lines']}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Covered Lines</div>
                    <div class="stat-value">{stats['covered_lines']}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Missing Lines</div>
                    <div class="stat-value">{stats['missing_lines']}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Tests</div>
                    <div class="stat-value">{stats['test_count']}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Passed</div>
                    <div class="stat-value">{stats['test_passed']}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Failed</div>
                    <div class="stat-value">{stats['test_failed']}</div>
                </div>
            </div>
            """)

            if stats["files"]:
                html.append('<div class="file-list"><strong>Files:</strong>')
                for file_info in stats["files"]:
                    html.append(f'<div class="file-item">{file_info["path"]} - {file_info["coverage"]:.1f}%</div>')
                html.append('</div>')

            html.append('</div>')

        html.append("""
    </div>
</body>
</html>
        """)

        return "\n".join(html)

    def generate_markdown_report(self, task_coverage: Dict[str, Dict]) -> str:
        """Generate a Markdown coverage report."""
        report = []
        report.append("# Cerby Phase 1 Test Coverage Report\n")
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        report.append(f"Coverage Threshold: {self.coverage_threshold}%\n")

        # Overall summary
        total_lines = sum(t["total_lines"] for t in task_coverage.values())
        covered_lines = sum(t["covered_lines"] for t in task_coverage.values())
        overall_coverage = (covered_lines / total_lines * 100) if total_lines > 0 else 0
        all_tasks_pass = all(t["meets_threshold"] for t in task_coverage.values())

        report.append("## Overall Summary\n")
        report.append(f"- Total Lines: {total_lines}")
        report.append(f"- Covered Lines: {covered_lines}")
        report.append(f"- Overall Coverage: {overall_coverage:.1f}%")
        report.append(f"- Status: {'✅ PASS' if all_tasks_pass else '❌ FAIL'}\n")

        # Task details
        report.append("## Task Coverage Details\n")

        for task, stats in sorted(task_coverage.items()):
            status = "✅" if stats["meets_threshold"] else "❌"
            report.append(f"### {task} {status}\n")
            report.append(f"- Coverage: **{stats['coverage_percent']:.1f}%**")
            report.append(f"- Lines: {stats['covered_lines']}/{stats['total_lines']}")
            report.append(f"- Missing: {stats['missing_lines']}")
            report.append(f"- Tests: {stats['test_passed']}/{stats['test_count']} passed")

            if stats["files"]:
                report.append("\nFiles:")
                for file_info in stats["files"]:
                    report.append(f"  - `{file_info['path']}`: {file_info['coverage']:.1f}%")

            report.append("")

        # Requirements checklist
        report.append("## Phase 2 Requirements Checklist\n")
        report.append("- [x] All subtasks have unit tests")
        report.append(f"- [{'x' if all_tasks_pass else ' '}] All tasks achieve >95% coverage")
        report.append("- [x] Test infrastructure is in place")
        report.append("- [x] Coverage reporting is automated")

        return "\n".join(report)

    def save_reports(self, task_coverage: Dict[str, Dict]) -> None:
        """Save coverage reports in multiple formats."""
        # Save HTML report
        html_report = self.generate_html_report(task_coverage)
        html_path = self.project_root / "coverage_report_phase1.html"
        with open(html_path, 'w') as f:
            f.write(html_report)
        print(f"HTML report saved to: {html_path}")

        # Save Markdown report
        md_report = self.generate_markdown_report(task_coverage)
        md_path = self.project_root / "coverage_report_phase1.md"
        with open(md_path, 'w') as f:
            f.write(md_report)
        print(f"Markdown report saved to: {md_path}")

        # Save JSON data
        json_path = self.project_root / "coverage_report_phase1.json"
        with open(json_path, 'w') as f:
            json.dump(task_coverage, f, indent=2)
        print(f"JSON data saved to: {json_path}")


def main():
    """Main function to generate coverage reports."""
    parser = argparse.ArgumentParser(description="Generate test coverage report for Phase 1")
    parser.add_argument("--run-tests", action="store_true", help="Run tests before generating report")
    parser.add_argument("--test-path", default="tests/unit", help="Path to test directory")
    parser.add_argument("--threshold", type=float, default=95.0, help="Coverage threshold percentage")

    args = parser.parse_args()

    reporter = TestCoverageReporter(project_root)
    reporter.coverage_threshold = args.threshold

    if args.run_tests:
        print("Running tests with coverage...")
        success = reporter.run_tests_with_coverage(args.test_path)
        if not success:
            print("Warning: Some tests failed")

    print("\nAnalyzing coverage by task...")
    task_coverage = reporter.analyze_coverage_by_task()

    print("\nGenerating reports...")
    reporter.save_reports(task_coverage)

    # Check if all tasks meet threshold
    all_pass = all(stats["meets_threshold"] for stats in task_coverage.values())

    if all_pass:
        print("\n✅ All tasks meet the coverage threshold!")
        print("Ready to proceed to Phase 2.")
    else:
        print("\n❌ Some tasks are below the coverage threshold.")
        failing_tasks = [task for task, stats in task_coverage.items() if not stats["meets_threshold"]]
        print(f"Failing tasks: {', '.join(failing_tasks)}")
        print("Please improve test coverage before proceeding to Phase 2.")
        sys.exit(1)


if __name__ == "__main__":
    main()
